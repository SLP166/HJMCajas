<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Control de Estacionamiento HJM</title>
<style>
  :root {
    --bg: #f0f4f8;
    --ink: #1f2937;
    --brand: #34495e;
    --brand-ink: #fff;
    --warn: #f59e0b;
    --ok-bg: #d4edda;
    --ok-ink: #155724;
    --bad-bg: #f8d7da;
    --bad-ink: #721c24;
    --blink-bg: #fff3cd;
  }
  * { box-sizing: border-box; }
  body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); margin: 0; color: var(--ink); }
  header { display: flex; gap: 12px; justify-content: space-between; align-items: center; background: var(--brand); padding: 10px 16px; color: var(--brand-ink); position: sticky; top: 0; z-index: 10; }
  header img { height: 44px; }
  header h1 { margin: 0; font-size: 20px; letter-spacing: .5px; flex: 1; text-align: center; }
  header .firma { font-size: 12px; font-style: italic; white-space: nowrap; opacity: .9; }
  header .estadoRed { font-size: 12px; font-weight: bold; }
  header .estadoRed.online { color: #10b981; }
  header .estadoRed.offline { color: #f59e0b; }

  .toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center; padding: 10px; background: #fff; border-bottom: 1px solid #e5e7eb; position: sticky; top: 64px; z-index: 9; }
  .toolbar button, .toolbar select, .toolbar label { font-size: 14px; }
  .btn { padding: 8px 14px; border: none; border-radius: 8px; cursor: pointer; background: var(--brand); color: var(--brand-ink); box-shadow: 0 2px 4px rgba(0,0,0,.08); transition: transform .05s ease, filter .2s ease; }
  .btn:hover { filter: brightness(1.05); }
  .btn:active { transform: translateY(1px); }
  .muted { color: #6b7280; font-size: 12px; }
  .contador {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 6px 10px;
    border-radius: 16px;
    font-size: 14px;
    font-weight: 500;
    margin: 0 4px;
  }
  .contador svg {
    flex-shrink: 0;
  }
  .vacios {
    background-color: var(--ok-bg);
    color: var(--ok-ink);
  }
  .ocupados {
    background-color: var(--bad-bg);
    color: var(--bad-ink);
  }
  .wrap { max-width: 1200px; margin: 0 auto; padding: 10px; }
  .contenedor-tablas { display: flex; gap: 20px; align-items: flex-start; }
  table { border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,.06); background: #fff; }
  table#tablaEstacionamiento { width: 100%; }
  table#tabla-vacios { width: 120px; }
  caption { font-weight: 600; padding: 8px; background: #fff; }
  thead th { position: sticky; top: calc(64px + 48px); background: var(--brand); color: var(--brand-ink); padding: 10px; text-align: center; }
  tbody { display: block; max-height: 520px; overflow: auto; }
  thead, tbody tr { display: table; width: 100%; table-layout: fixed; }
  th, td { padding: 10px; border-bottom: 1px solid #eee; text-align: center; font-size: 14px; }
  tr.ocupado { background-color: var(--bad-bg); color: var(--bad-ink); font-weight: 600; }
  tr.vacio { background-color: var(--ok-bg); color: var(--ok-ink); }
  .status { display: inline-flex; align-items: center; gap: 6px; padding: 2px 8px; border-radius: 999px; font-weight: 600; }
  .status.ok { background: #dcfce7; }
  .status.bad { background: #fee2e2; }
  .notice { display:flex; align-items:center; gap:8px; margin:8px 0; font-size: 13px; }
  .hidden { display: none !important; }
  @keyframes blink {
    0% { background-color: var(--blink-bg); }
    50% { background-color: inherit; }
    100% { background-color: var(--blink-bg); }
  }
  .blink { animation: blink 1s ease 2; }
  table#tabla-vacios tbody tr { background-color: var(--ok-bg); color: var(--ok-ink); }
  @media (max-width: 768px) {
    header { flex-direction: column; align-items: flex-start; gap: 6px; padding: 8px 12px; }
    header h1 { font-size: 16px; text-align: left; width: 100%; }
    header img { height: 36px; }
    .toolbar { flex-direction: column; align-items: stretch; gap: 6px; padding: 8px; }
    .toolbar button, .toolbar select, .toolbar label { font-size: 13px; width: 100%; }
    .contador {
      width: 100%;
      justify-content: center;
      margin: 2px 0;
    }
    table { font-size: 12px; }
    thead th, tbody td { padding: 6px 4px; }
    tbody { max-height: 300px; }
    .status { padding: 2px 6px; font-size: 12px; }
    .contenedor-tablas { flex-direction: column; }
    table#tabla-vacios { width: 100%; max-height: 200px; }
  }
</style>
</head>
<body>
<header>
  <img src="https://hjmintl.com/web/storage/configs/logo.png" alt="Logo HJM" loading="lazy">
  <h1>HJM Cajas y Equipo</h1>
  <div class="firma">By Santos LP</div>
  <div class="estadoRed" id="estadoRed" aria-live="polite">ONLINE</div>
</header>

<div class="toolbar">
  <button class="btn" id="btnActualizar" aria-label="Actualizar datos">Actualizar</button>
  <label><input type="checkbox" id="autoScroll" checked /> Scroll automático</label>
  <label><input type="checkbox" id="modoOffline" /> Modo offline</label>
  <span class="contador vacios" title="Espacios vacíos">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path d="M4 20h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2Z"></path>
    </svg>
    <span id="contadorVacios">0</span>
  </span>
  <span class="contador ocupados" title="Espacios ocupados">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2Z"></path>
    </svg>
    <span id="contadorOcupados">0</span>
  </span>
  <select id="freq" aria-label="Frecuencia de actualización">
    <option value="5000">Cada 5 s</option>
    <option value="10000">Cada 10 s</option>
    <option value="30000">Cada 30 s</option>
    <option value="60000">Cada 60 s</option>
  </select>
  <span class="muted" id="etagInfo" aria-live="polite"></span>
</div>

<div class="wrap">
  <div class="notice" id="msg" role="status" aria-live="polite"></div>
  <div class="contenedor-tablas">
    <table id="tablaEstacionamiento" aria-label="Estado del estacionamiento">
      <caption>Última actualización: <span id="lastUpdate">-</span></caption>
      <thead>
        <tr>
          <th scope="col">Localización</th>
          <th scope="col">Unidad</th>
          <th scope="col">Estado</th>
          <th scope="col">Equipos</th>
          <th scope="col">Condición</th>
          <th scope="col">Fecha de ingreso</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
    <table id="tabla-vacios" aria-label="Espacios vacíos">
      <thead>
        <tr><th scope="col">Vacíos</th></tr>
      </thead>
      <tbody id="cuerpo-vacios"></tbody>
    </table>
  </div>
</div>

<script>
const MAX_BACKOFF_MS = 30000;
const INITIAL_BACKOFF_MS = 2000;
const DB_NAME = 'hjm-parking';
const DB_STORE = 'cache';
const listaEspacios = [
  "n01","n02","n03","n04","n05","n06","n07","n08","n09","n10",
  "n11","n12","n13","n14","n15","n16","n17","n18","n19","n20",
  "n21","n22","n23","n24","n25","n26","n27","n28","n29","n30",
  "n31","n32","n33","n34","n35",
  "s01","s02","s03","s04","s05","s06","s07","s08","s09","s10",
  "s11","s12","s13","s14","s15","s16","s17","s18","s19","s20",
  "s21","s22","s23","s24","s25","s26","s27","s28","s29","s30",
  "s31","s32","s33","s34","s35","s36","s37","s38","s39","s40",
  "s41","s42","s43","s44","s45","s46"
];
const el = {
  tbody: document.querySelector('#tablaEstacionamiento tbody'),
  cuerpoVacios: document.getElementById('cuerpo-vacios'),
  btnActualizar: document.getElementById('btnActualizar'),
  autoScroll: document.getElementById('autoScroll'),
  modoOffline: document.getElementById('modoOffline'),
  freq: document.getElementById('freq'),
  lastUpdate: document.getElementById('lastUpdate'),
  msg: document.getElementById('msg'),
  etagInfo: document.getElementById('etagInfo'),
  estadoRed: document.getElementById('estadoRed'),
  contadorVacios: document.getElementById('contadorVacios'),
  contadorOcupados: document.getElementById('contadorOcupados')
};
let rafId = null;
let userScrolling = false;
let scrollTimeout = null;
let timerId = null;
const ultimoEstadoInfo = new Map();
const trMap = new Map();
let ultimaLineaProcesada = 0;
let lastETag = null;
let lastModified = null;
let backoffMs = 0;
let db = null;
let isInitialLoad = true;

async function openDB() {
  return new Promise((resolve) => {
    try {
      const request = indexedDB.open(DB_NAME, 1);
      request.onupgradeneeded = (event) => {
        if (!event.target.result.objectStoreNames.contains(DB_STORE)) {
          event.target.result.createObjectStore(DB_STORE);
        }
      };
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => resolve(null);
    } catch (error) {
      resolve(null);
    }
  });
}

async function dbSet(key, value) {
  if (!db) db = await openDB();
  if (!db) return;
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(value, key);
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function dbGet(key) {
  if (!db) db = await openDB();
  if (!db) return null;
  return new Promise((resolve, reject) => {
    const tx = db.transaction(DB_STORE, 'readonly');
    const req = tx.objectStore(DB_STORE).get(key);
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

function showMsg(text, type = 'info') {
  el.msg.textContent = text;
  el.msg.classList.remove('hidden');
  el.msg.classList.remove('msg-error', 'msg-warning', 'msg-info');
  if (type === 'error') el.msg.classList.add('msg-error');
  else if (type === 'warning') el.msg.classList.add('msg-warning');
  else el.msg.classList.add('msg-info');
}

function hideMsg() {
  el.msg.classList.add('hidden');
}

function setEstadoRed(status) {
  el.estadoRed.textContent = status;
  if (status === 'ONLINE') {
    el.estadoRed.classList.add('online');
    el.estadoRed.classList.remove('offline');
  } else {
    el.estadoRed.classList.add('offline');
    el.estadoRed.classList.remove('online');
  }
}

function actualizarIndicadorPorNavegador() {
  if (el.modoOffline.checked) setEstadoRed('OFFLINE');
  else setEstadoRed(navigator.onLine ? 'ONLINE' : 'OFFLINE');
}

window.addEventListener('online', actualizarIndicadorPorNavegador);
window.addEventListener('offline', actualizarIndicadorPorNavegador);

function autoScrollFunc() {
  if (!el.autoScroll.checked || userScrolling) {
    rafId = requestAnimationFrame(autoScrollFunc);
    return;
  }
  if (el.tbody.scrollHeight > el.tbody.clientHeight) {
    const step = Math.max(1, Math.floor(el.tbody.clientHeight * 0.25));
    if (el.tbody.scrollTop + el.tbody.clientHeight >= el.tbody.scrollHeight - 2) {
      el.tbody.scrollTop = 0;
    } else {
      el.tbody.scrollTop += step;
    }
  }
  if (el.cuerpoVacios.scrollHeight > el.cuerpoVacios.clientHeight) {
    const stepVacios = Math.max(1, Math.floor(el.cuerpoVacios.clientHeight * 0.25));
    if (el.cuerpoVacios.scrollTop + el.cuerpoVacios.clientHeight >= el.cuerpoVacios.scrollHeight - 2) {
      el.cuerpoVacios.scrollTop = 0;
    } else {
      el.cuerpoVacios.scrollTop += stepVacios;
    }
  }
  rafId = requestAnimationFrame(autoScrollFunc);
}

el.tbody.addEventListener('scroll', () => {
  if (el.autoScroll.checked) {
    userScrolling = true;
    if (scrollTimeout) clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 1500);
  }
});

el.cuerpoVacios.addEventListener('scroll', () => {
  if (el.autoScroll.checked) {
    userScrolling = true;
    if (scrollTimeout) clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 1500);
  }
});

function actualizarVacios(updated = []) {
  const fragment = document.createDocumentFragment();
  listaEspacios.forEach(espacio => {
    const info = ultimoEstadoInfo.get(espacio) || { estado: 'salida' };
    if (info.estado !== 'entrada') {
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.textContent = espacio.toUpperCase();
      if (updated.includes(espacio)) {
        tr.classList.add('blink');
        setTimeout(() => tr.classList.remove('blink'), 2000);
      }
      tr.appendChild(td);
      fragment.appendChild(tr);
    }
  });
  el.cuerpoVacios.innerHTML = '';
  el.cuerpoVacios.appendChild(fragment);
}

function render() {
  const updated = [];
  const fragment = document.createDocumentFragment();
  trMap.forEach((tr, espacio) => {
    const info = ultimoEstadoInfo.get(espacio) || { estado: 'salida' };
    if (info.estado !== 'entrada') {
      tr.remove();
      trMap.delete(espacio);
      updated.push(espacio);
    }
  });
  listaEspacios.forEach(espacio => {
    const info = ultimoEstadoInfo.get(espacio) || {
      estado: 'salida',
      equipos: '',
      condicion: '',
      unidad: '',
      fechaIngreso: null
    };
    if (info.estado === 'entrada') {
      let tr = trMap.get(espacio);
      const isNew = !tr;
      if (isNew) {
        tr = document.createElement('tr');
        trMap.set(espacio, tr);
        updated.push(espacio);
      }
      tr.className = 'ocupado';
      const fechaTxt = info.fechaIngreso ? info.fechaIngreso.toLocaleString() : '';
      tr.innerHTML = `
        <td>${espacio.toUpperCase()}</td>
        <td>${info.unidad || ''}</td>
        <td><span class="status bad">Ocupado</span></td>
        <td>${info.equipos || ''}</td>
        <td>${info.condicion || ''}</td>
        <td>${fechaTxt}</td>
      `;
      if (isNew) fragment.appendChild(tr);
      if (updated.includes(espacio)) {
        tr.classList.add('blink');
        setTimeout(() => tr.classList.remove('blink'), 2000);
      }
    }
  });
  el.tbody.appendChild(fragment);
  actualizarVacios(updated);
  const totalOcupados = Array.from(ultimoEstadoInfo.values()).filter(info => info.estado === 'entrada').length;
  el.contadorOcupados.textContent = totalOcupados;
  el.contadorVacios.textContent = listaEspacios.length - totalOcupados;
  el.lastUpdate.textContent = new Date().toLocaleTimeString();
}

async function fetchCSV(url) {
  if (!url || typeof url !== 'string' || !url.startsWith('http')) throw new Error('URL no válida');
  if (el.modoOffline.checked) {
    setEstadoRed('OFFLINE');
    throw new Error('FORCED_OFFLINE');
  }
  const headers = {};
  if (lastETag) headers['If-None-Match'] = lastETag;
  if (lastModified) headers['If-Modified-Since'] = lastModified;
  let attempts = 0;
  const maxAttempts = 5;
  while (attempts < maxAttempts) {
    try {
      const response = await fetch(url, { headers, cache: 'no-store', referrerPolicy: 'no-referrer' });
      if (response.status === 304) {
        setEstadoRed('ONLINE');
        return { text: null, etag: lastETag, lastModified };
      }
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const etag = response.headers.get('ETag');
      const lm = response.headers.get('Last-Modified');
      const text = await response.text();
      if (typeof text !== 'string' || text.length === 0) throw new Error('Respuesta vacía o no válida');
      backoffMs = 0;
      setEstadoRed('ONLINE');
      return { text, etag, lastModified: lm };
    } catch (error) {
      attempts++;
      setEstadoRed('OFFLINE');
      if (attempts >= maxAttempts) throw error;
      backoffMs = Math.min(backoffMs + INITIAL_BACKOFF_MS, MAX_BACKOFF_MS);
      await new Promise(resolve => setTimeout(resolve, backoffMs));
    }
  }
  throw new Error('No se pudo obtener el CSV después de varios intentos');
}

function parseCSV(text) {
  if (typeof text !== 'string' || text.trim().length === 0) throw new Error('Datos CSV no válidos');
  const lines = text.split(/\r?\n/).filter(line => line.trim().length > 0);
  if (lines.length === 0) return { headers: [], rows: [] };
  const headers = lines[0].split(',').map(h => h.trim());
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(',');
    while (cols.length < headers.length) cols.push('');
    rows.push(cols.map(c => c.trim()));
  }
  return { headers, rows };
}

function resolveIndices(headers) {
  const lowerHeaders = headers.map(h => h.toLowerCase());
  const idxFecha = lowerHeaders.findIndex(h => h.includes('fecha') && h.includes('hora'));
  const idxEstado = lowerHeaders.findIndex(h => h === 'estado');
  const idxLocal = lowerHeaders.findIndex(h => h.includes('localizaci'));
  const idxEquip = lowerHeaders.findIndex(h => h.includes('equipos'));
  const idxCond = lowerHeaders.findIndex(h => h === 'condición' || h === 'condicion');
  const idxUnidad = lowerHeaders.findIndex(h => h.includes('unidad'));
  if ([idxFecha, idxEstado, idxLocal].some(i => i === -1)) throw new Error('El formato del CSV no coincide con lo esperado');
  return { idxFecha, idxEstado, idxLocal, idxEquip, idxCond, idxUnidad };
}

function applyRows(headers, rows) {
  const { idxFecha, idxEstado, idxLocal, idxEquip, idxCond, idxUnidad } = resolveIndices(headers);
  for (let i = Math.max(0, ultimaLineaProcesada); i < rows.length; i++) {
    const row = rows[i];
    if (!Array.isArray(row) || row.length === 0) continue;
    const loc = (row[idxLocal] || '').trim();
    const estado = (row[idxEstado] || '').trim().toLowerCase();
    const equipos = (row[idxEquip] || '').trim();
    const condicion = (row[idxCond] || '').trim();
    const unidad = (row[idxUnidad] || '').trim();
    let fecha;
    try {
      fecha = new Date((row[idxFecha] || '').trim());
      if (isNaN(fecha.getTime())) fecha = null;
    } catch (e) {
      fecha = null;
    }
    if (!loc) continue;
    ultimoEstadoInfo.set(loc, { estado, equipos, condicion, unidad, fechaIngreso: fecha });
  }
  ultimaLineaProcesada = rows.length;
}

async function cargarDatos() {
  try {
    if (isInitialLoad) showMsg('Cargando datos iniciales...', 'info');
    const urlCSV = await fetch('gary.dat', { cache: 'no-store' })
      .then(response => {
        if (!response.ok) throw new Error('No se pudo obtener gary.dat');
        return response.text();
      })
      .then(text => {
        const trimmed = text.trim();
        if (!trimmed) throw new Error('Contenido de gary.dat vacío');
        return atob(trimmed);
      })
      .catch(error => {
        throw new Error('No se pudo obtener la URL del CSV');
      });
    if (!urlCSV) throw new Error('URL del CSV no disponible');
    const result = await fetchCSV(urlCSV);
    if (result.text === null) {
      el.etagInfo.textContent = lastETag ? `ETag vigente: ${lastETag}` : '';
      el.lastUpdate.textContent = new Date().toLocaleTimeString();
      hideMsg();
      return;
    }
    const { headers, rows } = parseCSV(result.text);
    resolveIndices(headers);
    applyRows(headers, rows);
    try {
      await dbSet('ultimoEstadoInfo', Array.from(ultimoEstadoInfo.entries()));
      await dbSet('ultimaLineaProcesada', ultimaLineaProcesada);
    } catch (error) {}
    lastETag = result.etag || lastETag;
    lastModified = result.lastModified || lastModified;
    el.etagInfo.textContent = lastETag ? `ETag: ${lastETag}` : '';
    render();
    hideMsg();
    if (isInitialLoad) {
      isInitialLoad = false;
      showMsg('Datos cargados correctamente', 'info');
      setTimeout(hideMsg, 3000);
    }
  } catch (error) {
    setEstadoRed('OFFLINE');
    if (error.message === 'FORCED_OFFLINE') showMsg('Modo offline activado', 'info');
    else showMsg(`Error: ${error.message}`, 'error');
    if (isInitialLoad) {
      try {
        const stored = await dbGet('ultimoEstadoInfo');
        if (stored) {
          ultimoEstadoInfo.clear();
          stored.forEach(([k, v]) => ultimoEstadoInfo.set(k, v));
          const ultimaLinea = await dbGet('ultimaLineaProcesada');
          ultimaLineaProcesada = ultimaLinea || 0;
          render();
          showMsg('Usando datos cacheados', 'warning');
        }
      } catch (cacheError) {}
    }
  }
}

el.btnActualizar.addEventListener('click', () => {
  showMsg('Actualizando datos...', 'info');
  cargarDatos();
});

el.modoOffline.addEventListener('change', () => {
  actualizarIndicadorPorNavegador();
  if (el.modoOffline.checked) showMsg('Modo offline activado', 'info');
  else showMsg('Modo online, actualizando datos...', 'info');
});

el.freq.addEventListener('change', () => {
  if (timerId) clearInterval(timerId);
  const freq = Number(el.freq.value);
  if (freq > 0) timerId = setInterval(cargarDatos, freq);
});

(async () => {
  try {
    const stored = await dbGet('ultimoEstadoInfo');
    if (stored) {
      ultimoEstadoInfo.clear();
      stored.forEach(([k, v]) => ultimoEstadoInfo.set(k, v));
      const ultimaLinea = await dbGet('ultimaLineaProcesada');
      ultimaLineaProcesada = ultimaLinea || 0;
      render();
    }
    autoScrollFunc();
    const freq = Number(el.freq.value);
    if (freq > 0) timerId = setInterval(cargarDatos, freq);
    await cargarDatos();
  } catch (error) {
    showMsg('Error al inicializar la aplicación', 'error');
  }
})();

window.addEventListener('beforeunload', () => {
  if (rafId) cancelAnimationFrame(rafId);
  if (timerId) clearInterval(timerId);
  if (scrollTimeout) clearTimeout(scrollTimeout);
});
</script>
</body>
</html>
